import { ConflictException, Injectable } from '@nestjs/common';
import { CreateTicketDto } from './dto/create-ticket.dto';
import { UpdateTicketDto } from './dto/update-ticket.dto';
import { UserEntity } from 'src/user/entities/user.entity';
import { TicketEntity } from './entities/ticket.entity';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { UserService } from 'src/user/user.service';
import { ClientService } from 'src/client/client.service';
import { MatriculeGeneratorService } from 'src/helpers/matricule-ticket/matricule-generator.service';

@Injectable()
export class TicketService {
  constructor(
    @InjectRepository(TicketEntity)
    private ticketRepository: Repository<TicketEntity>,
    private userService: UserService,
    private customerService: ClientService,
    private matriculeGenerator: MatriculeGeneratorService,
  ) {}

  /**
   *
   * @param data
   * @param user
   */
  async create(data: CreateTicketDto, user: UserEntity): Promise<TicketEntity> {
    const {
      assignTo: userID,
      customer: clientID,
      description,
      subject,
      priority,
      order,
      supervisors,
    } = data;

    //find entity relationship
    const isExist = await this.ticketRepository.findOne({ order: order });
    console.log(isExist);
    if (isExist)
      throw new ConflictException(`a ticket with order ${order} exist already`);

    const customer = await this.customerService._findById(clientID);
    const assignTo = await this.userService.findOne(userID); //where user est assignÃ© a ce client
    //create new ticket object
    const newTkt = new TicketEntity();
    newTkt.customer = customer;
    newTkt.assignTo = assignTo;
    newTkt.order = order;
    newTkt.description = description;
    newTkt.priority = priority;
    newTkt.subject = subject;
    newTkt.createdBy = user.username; //author
    //add supervisors manyToMany table
    if (supervisors && supervisors.length > 0) {
      newTkt.supervisors = [];
      for (let i = 0; i < supervisors.length; i++) {
        const supervisor = await this.userService.findOne(supervisors[i]);
        console.debug(supervisor);
        newTkt.supervisors.push(supervisor);
      }
    }

    //add matricule generated by service generator
    const matricule = await this.matriculeGenerator.handle(customer.company);
    newTkt.matricule = matricule;
    // then saving ticket.
    const ticket = await this.ticketRepository.create(newTkt);
    await this.ticketRepository.save(ticket);

    //custom retour of tkt
    return ticket;
  }

  findAll() {
    return `This action returns all ticket`;
  }

  findOne(id: number) {
    return `This action returns a #${id} ticket`;
  }

  update(id: number, updateTicketDto: UpdateTicketDto) {
    return `This action updates a #${id} ticket`;
  }

  remove(id: number) {
    return `This action removes a #${id} ticket`;
  }
}
