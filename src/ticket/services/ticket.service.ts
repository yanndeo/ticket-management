import {
  BadRequestException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { CreateTicketDto } from '../dto/create-ticket.dto';
import { UpdateTicketDto } from '../dto/update-ticket.dto';
import { UserEntity } from 'src/user/entities/user.entity';
import { TicketEntity } from '../entities/ticket.entity';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { UserService } from 'src/user/services/user.service';
import { ClientService } from 'src/client/services/client.service';
import { MatriculeGeneratorService } from 'src/helpers/matricule-ticket/matricule-generator.service';

@Injectable()
export class TicketService {
  constructor(
    @InjectRepository(TicketEntity)
    private ticketRepository: Repository<TicketEntity>,
    private userService: UserService,
    private customerService: ClientService,
    private matriculeGenerator: MatriculeGeneratorService,
  ) {}

  /**
   *
   * @param data
   * @param user
   */
  async create(data: CreateTicketDto, user: UserEntity) {
    const assignTo = await this.userService.findOne(data.assignTo); //where user est assignÃ© a ce client
    const customer = await this.customerService._findById(data.customer);
    //create new ticket object
    try {
      const newTkt = new TicketEntity();
      newTkt.customer = customer;
      newTkt.assignTo = assignTo;
      newTkt.order = data.order ?? 'NR';
      newTkt.description = data.description;
      newTkt.priority = data.priority;
      newTkt.subject = data.subject;
      newTkt.createdBy = user?.username; //author

      //add supervisors manyToMany table
      if (data?.supervisors && data?.supervisors?.length > 0) {
        newTkt.supervisors = [];
        for (let i = 0; i < data.supervisors?.length; i++) {
          const supervisor = await this.userService.findOne(data.supervisors[i]);
          newTkt.supervisors.push(supervisor);
        }
      }

      //add matricule generated by service generator
      newTkt.matricule = await this._generateMatricule(data.customer);

      //then saving ticket.
      const ticket = await this.ticketRepository.create(newTkt);
      const createdTicket = await this.ticketRepository.save(ticket);

      //customized response object
      return this._partialDataTicket(createdTicket);
    } catch (error) {
      console.debug(error);
      throw new BadRequestException(error.message);
      //send message to root admin
    }
  }

  /**
   * admin
   * send all tickets brut
   */
  async findAll() {
    return await this.ticketRepository
      .createQueryBuilder('ticket')
      .leftJoin('ticket.customer', 'client')
      .leftJoin('ticket.assignTo', 'engineer')
      .leftJoin('ticket.supervisors', 'supervisor')
      .select([
        'ticket.id',
        'ticket.matricule',
        'ticket.order',
        'ticket.priority',
        'ticket.status',
        'ticket.subject',
        'ticket.description',
        'ticket.comment',
        'ticket.created_at',
        'ticket.image_1',
        'ticket.image_2',
        'ticket.image_3',
      ])
      .addSelect(['client.id', 'client.company', 'client.logo'])
      .addSelect(['engineer.id', 'engineer.username'])
      .addSelect(['supervisor.id', 'supervisor.username'])
      .orderBy('ticket.id', 'DESC')
      //.getSql();
      //.take(15)
      .getMany();
  }

  /**
   *
   * @param id
   */
  async findOne(id: number) {
    const ticket = await this.ticketRepository
      .createQueryBuilder('ticket')
      .where('ticket.id = :id', { id })
      .leftJoin('ticket.customer', 'client')
      .leftJoin('ticket.assignTo', 'user')
      .leftJoin('ticket.supervisors', 'supervisor')
      .addSelect(['client.id', 'client.company', 'client.logo', 'client.site'])
      .addSelect(['user.id', 'user.username'])
      .addSelect(['supervisor.id', 'supervisor.username'])
      .getOne();

    if (!ticket) throw new NotFoundException(`ticket ${id} not found`);

    //isAssociated = createQueryBuilder('client)
    //.where('client.id = ticket.customer.id)
    //.select('client.users', 'users',''where user.id =@user.id)

    //if isAssociated , || user.hasRole(admin, manager)

    return ticket;
  }

  /**
   * update ticket
   * @param id
   * @param data
   * @param user
   */
  async update(id: number, data: UpdateTicketDto, user: UserEntity) {
    //check if ticket exist in database
    const tkt = await this.ticketRepository.findOne(id);
    if (!tkt) throw new NotFoundException(`ticket ${id} doesn't exist`);
    //replace all item of data 'object or keep tkt intact
    tkt.order = data.order ?? tkt.order;
    tkt.subject = data.subject ?? tkt.subject;
    tkt.status = data.status ?? tkt.status;
    tkt.priority = data.priority ?? tkt.priority;
    tkt.description = data.description ?? tkt.description;
    tkt.comment = data.comment ?? tkt.comment;
    tkt.assignTo = data.assignTo
      ? await this.userService.findOne(data.assignTo)
      : tkt.assignTo;
    tkt.matricule =
      data.customer && +data.customer !== tkt.customer.id
        ? await this._generateMatricule(data.customer) //need change customer => change matricule
        : tkt.matricule;
    tkt.customer = data.customer
      ? await this.customerService._findById(data.customer)
      : tkt.customer;
    tkt.image_1 = data.image_1 ?? tkt.image_1;
    tkt.image_2 = data.image_2 ?? tkt.image_2;
    tkt.image_3 = data.image_3 ?? tkt.image_3;

    //add supervisors manyToMany table
    if (data.supervisors && data.supervisors?.length > 0) {
      tkt.supervisors = [];
      for (let i = 0; i < data.supervisors?.length; i++) {
        const supervisor = await this.userService.findOne(data.supervisors[i]);
        tkt.supervisors.push(supervisor);
      }
    }
    //save patch changement
    const ticket = await this.ticketRepository.save(tkt);
    return await this._partialDataTicket(ticket);
  }

  /**
   * delete ticket
   * admin, customer, manager
   * @param id
   */
  async softDelete(id: number) {
    const ticket = await this.ticketRepository.findOne(id);
    if (!ticket) throw new NotFoundException();
    else return await this.ticketRepository.softDelete(id);
  }

  /**
   * restore id
   * admin
   * @param id
   */
  async restore(id: number) {
    const tkt = this.ticketRepository
      .createQueryBuilder('ticket')
      .where('ticket.id = :id', { id })
      .select('ticket.id')
      .getOne();

    if (!tkt) throw new NotFoundException();
    return await this.ticketRepository.restore(id);
  }

  /**
   *
   * @param id
   */
  async remove(id: number) {
    const ticket = await this.ticketRepository.findOne(id);
    if (!ticket) throw new NotFoundException(`this ticket doesn't exist`);
    return await this.ticketRepository.remove(ticket);
  }

  /**
   * find id of customer and
   * find number of ticket associated
   * to this company
   * @param companyID
   */
  async _generateMatricule(companyID: number): Promise<string> {
    const customer = await this.customerService._findById(companyID);
    const { company, id } = customer;

    const count = await this.ticketRepository
      .createQueryBuilder('ticket')
      .leftJoin('ticket.customer', 'customer')
      .where('customer.id = :id', { id })
      .select('DISTINCT ("ticket.id")')
      .getCount();

    return await this.matriculeGenerator.handle(count, company);
  }

  /**
   * private meth
   * customize data ticket object
   * returned
   * @param ticket
   */
  _partialDataTicket(ticket: TicketEntity) {
    return {
      id: ticket.id,
      matricule: ticket.matricule,
      order: ticket.order,
      subject: ticket.subject,
      priority: ticket.priority,
      status: ticket.status,
      description: ticket.description,
      comment: ticket.comment,
      image_1: ticket.image_1,
      image_2: ticket.image_2,
      image_3: ticket.image_3,
      assignTo: {
        id: ticket.assignTo.id,
        username: ticket.assignTo.username,
        email: ticket.assignTo.email,
        _fullName: ticket.assignTo.Fullname,
        _photo: ticket.assignTo.Photo,
        _tel: ticket.assignTo.profile?.mobile ?? ticket.assignTo.profile?.fixe,
      },
      customer: {
        id: ticket.customer.id,
        company: ticket.customer.company,
        logo: ticket.customer.logo,
      },
      supervisors: ticket.supervisors?.map((item) => {
        return {
          id: item.id,
          username: item.username,
          email: item.email,
          _fullName: item.Fullname,
          _photo: item.Photo,
          //_tel: item.profile?.mobile ?? item.profile?.fixe,
        };
        /* const {
          validated_at,
          salt,
          password,
          delete_at,
          created_at,
          updated_at,
          roles,
          ...res
        } = item;
        return res; */
      }),
      createdBy: ticket.createdBy,
    };
  }
}
